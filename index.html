<html><head><meta http-equiv="content-Type" content="text/html; charset=windows-1252">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" bütünlüğü="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonim">
    <üslup>
        p {
    yazı tipi boyutu: 40 piksel;
    kenar boşluğu:0;
    harf aralığı:3px;
        }
    </stil></kafa>
    <bağlantı href="https://fonts.googleapis.com/css?family=Kanit" rel="stil sayfası">
    <başlık> ;D </başlık>
    <gövde oncontextmenu="false döndür;" unselectable="on" onselectstart="yanlış döndür;" ><canvas genişliği="715" yükseklik="974"></tuval>
      <ses id="ses" önyükle="" otomatik oynatma="" döngüsü="">
        <kaynak türü="ses/mp3" src="https://cdn.discordapp.com/attachments/797817393673797673/799923938423078912/siteacikkaynaklialabilirsinkorkma.mp3">
      </ses>
    <üslup>
            img[src*="https://cdn.rawgit.com/000webhost/logo/e9bd13f7/footer-powered-by-000webhost-white2.png"] {
        görüntü: none;}
            </üslup>
         <komut dosyası türü="metin/javascript">
        penceresini açın. onkeydown = işlev(evt) {
            if(evt. keyCode == 123 ||. keyCode == 85 ||. keyCode == 17 ||. keyCode == 16 ||. keyCode == 74 ||. keyCode == 116 ||. keyCode == 73) false döndürür;
        };
    
        penceresini açın. onkeypress = işlev(evt) {
            if(evt. keyCode == 123 ||. keyCode == 85 ||. keyCode == 17 ||. keyCode == 16 ||. keyCode == 74 ||. keyCode == 116 ||. keyCode == 73) false döndürür;
        };
        
    işlevi disableF5(e) { if ((e. hangi || e. keyCode) == 116) e. preventDefault(); };
    $(belge). on("keydown", disableF5);
    </betik>
    <üslup>
    body{-webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; -o-user-select:none; kullanıcı-seç:yok;}
    a {
    renk: devralma;
        metin dekorasyonu: hiçbiri !önemli;
    }
    
    
    
 . orta {
    yazı tipi ailesi: 'Montserrat', sans-serif;
    
    
      konum: sabit; /* veya mutlak */
      üst: 50%;
      sol: 50%;
      /* kendi öneklerinizi getirin */
      dönüştürme: translate(-%50, -50%);
          animasyon: soldurma 3s;
        -moz-animasyon: solgun 3s; /* Firefox */
        -webkit-animasyon: solgun 3s; /* Safari ve Chrome */
        -o-animasyon: soldurma 3s; /* Opera */
 }â&#128; &#139;
    
    @keyframes solgunluk {
        kaynak {
            opaklık:0;
        }
        hedef {
            opaklık:1;
        }
    }
    @-moz-keyframes fadein { /* Firefox */
        from {
            opacity:0;
        }
        to {
            opacity:1;
        }
    }
    @-webkit-keyframes fadein { /* Safari and Chrome */
        from {
            opacity:0;
        }
        to {
            opacity:1;
        }
    }
    @-o-keyframes fadein { /* Opera */
        from {
            opacity:0;
        }
        to {
            opacity: 1;
        }
    }
    </style>
    
    
    <div class="center">
    <center>
    <p>fwrkan#1000
    </p>
    <div style="letter-spacing: 3;font-size: 15;"><div id="center">
                <div class="animated fadeInDown">
    
                </div>
                
                <div class="animated fadeInUp">
                    
                        
                        <pre><pre align="middle"><a href="https://discord.com/users/929434368915669042" target="_blank"><i class="fab fa-python"></i></a> <a href="https://discord.com/users/929434368915669042" target="_blank"><i class="fab fa-js-square"></i></a> <a href="https://discord.com/users/929434368915669042" target="_blank"><i class="fab fa-java"></i></a>  <a href="https://github.com/fwrkann" target="_blank"><i class="fab fa-github"></i></a> <a href="https://discord.com/users/929434368915669042" target="_blank"><i class="fab fa-discord"></i></a> <a href="https://open.spotify.com/user/31a35fdutrwxzgs4gbpex7hfnnku" target="_blank"><i class="fab fa-spotify"></i></a> <a href="https://www.twitch.tv/fwrkann" target="_blank"><i class="fab fa-twitch"></i></a>  </pre></pre> 
                                <center><div id="clockDisplay" class="clockStyle">09:44:37 PM</div></center>
            <script>
                function renderTime() {
                var currentTime = new Date();
                var diem = "AM";
                var h = currentTime.getHours();
                var m = currentTime.getMinutes();
                var s = currentTime.getSeconds();
                setTimeout('renderTime()',1000);
                if (h == 0) {
                    h = 12;
                } else if (h > 12) { 
                    h = h - 12;
                    diem="PM";
                }
                if (h < 10) {
                    h = "0" + h;
                }
                if (m < 10) {
                    m = "0" + m;
                }
                if (s < 10) {
                    s = "0" + s;
                }
                var myClock = document.getElementById('clockDisplay');
                myClock.textContent = h + ":" + m + ":" + s + " " + diem;
                myClock.innerText = h + ":" + m + ":" + s + " " + diem;
                }
                renderTime();
            </script>
                    </div>
                </div>
                            
                          </div>
    <br>
    <div id="pp" style="cursor: pointer; letter-spacing: 2px; font-size: 14px;" onclick="pVid();"><i class="fas fa-play"></i></div>
    </center>
    </div>
    <script type="text/javascript">
    var audio = document.getElementById("audio"); 
    
    function pVid() { 
        audio.paused ? audio.play() : audio.pause();
    }
    </script>
    
    <style>
    html, body {
      overflow: hidden;
      color: #fefeff;
    }
    body {
      margin: 0;
      position: absolute;
      width: 100%;
      height: 100%;
    }
    canvas {
      width: 100%;
      height: 100%;
      z-index: -999999999;
    }
    [sınıf^="harf"] {
      -webkit-geçiş: opaklık 3s kolaylığı;
      -moz-geçiş: opaklık 3s kolaylığı;
      geçiş: opaklık 3s kolaylığı;
    }
 . harf-0 {
      geçiş gecikmesi: 0,2s;
    }
 . mektup-1 {
      geçiş gecikmesi: 0,4s;
    }
 . mektup-2 {
      geçiş gecikmesi: 0,6s;
    }
 . mektup-3 {
      geçiş gecikmesi: 0,8s;
    }
 . mektup-4 {
      geçiş gecikmesi: 1.0s;
    }
 . harf-5 {
      geçiş gecikmesi: 1,2 inç;
    }
 . mektup-6 {
      geçiş gecikmesi: 1,4s;
    }
 . mektup-7 {
      geçiş gecikmesi: 1,6s;
    }
 . mektup-8 {
      geçiş gecikmesi: 1,8s;
    }
 . mektup-9 {
      geçiş gecikmesi: 2.0s;
    }
 . mektup-10 {
      geçiş gecikmesi: 2.2s;
    }
 . mektup-11 {
      geçiş gecikmesi: 2,4s;
    }
 . mektup-12 {
      geçiş gecikmesi: 2,6s;
    }
 . mektup-13 {
      geçiş gecikmesi: 2,8s;
    }
 . mektup-14 {
      geçiş gecikmesi: 3.0s;
    }
 . mektup-15 {
      geçiş gecikmesi: 3,2 inç;
    }
    </üslup>
    <betik>
    'katı kullanmak';
    
    var canvas = belge. getElementsByTagName( 'tuval' )[ 0 ];
    
    tuval. width = tuval. clientWidth;
    tuval. yükseklik = tuval. clientHeight;
    
    var yapılandırması = {
        TEXTURE_DOWNSAMPLE: 1,
        DENSITY_DISSIPATION: 0.98,
        VELOCITY_DISSIPATION: 0.99,
        PRESSURE_DISSIPATION: 0.8,
        PRESSURE_ITERATIONS: 25,
        KıVRıLMA: 30,
        SPLAT_RADIUS: 0.005
    };
    
    var işaretçileri   = [];
    var splatStack = [];
    
    var _getWebGLContext = getWebGLContext (tuval );
    var gl = _getWebGLContext. Gl;
    var ext = _getWebGLContext. Ext;
    var support_linear_float = _getWebGLContext. support_linear_float;
    
    getWebGLContext (tuval) işlevinin ) {
    
        var params = {
            alfa: yanlış,
            derinlik: yanlış,
            şablon: yanlış,
            antialias: yanlış
        };
    
        var gl = tuval. getContext( 'webgl2', params );
    
        var isWebGL2 = ! Ne yapıyorsun? Gl;
    
        eğer ( ! isWebGL2 ) gl = tuval. getContext ( 'webgl', params ) || tuval. getContext( 'experimental-webgl', params );
    
        var halfFloat = gl. getExtension( 'OES_texture_half_float' );
        var support_linear_float = gl. getExtension( 'OES_texture_half_float_linear' );
    
        if ( isWebGL2 ) {
            gl. getExtension( 'EXT_color_buffer_float' );
            support_linear_float = gl. getExtension( 'OES_texture_float_linear' );
        }
    
        gl. clearColor( 0.0, 0.0, 0.0, 1.0 );
    
        var internalFormat = isWebGL2 ? gl. RGBA16F : gl. RGBA;
        var internalFormatRG = isWebGL2 ? gl. RG16F : gl. RGBA;
        var formatRG = isWebGL2 ? gl. RG : gl. RGBA;
        var texType = isWebGL2 ? gl. HALF_FLOAT : halfFloat. HALF_FLOAT_OES;
    
        dönmek {
            gl: gl,
            ext: {
                internalFormat: internalFormat,
                internalFormatRG: internalFormatRG,
                formatRG: formatRG,
                texType: texType
            },
            support_linear_float: support_linear_float
        };
    }
    
    işlev işaretçisiPrototype() {
        i̇şte bu. id = -1;
        i̇şte bu. x = 0;
        i̇şte bu. y = 0;
        i̇şte bu. dx = 0;
        i̇şte bu. dy = 0;
        i̇şte bu. aşağı = yanlış;
        i̇şte bu. moved = yanlış;
        i̇şte bu. renk = [ 30, 0, 300 ];
    }
    
    işaretçiler. push(yeni pointerPrototype() );
    
    var GLProgram = işlevi () {
        
        fonksiyon GLProgram ( köşeShader, fragmentShader ) {
    
            eğer ( ! (GLProgram'ın bu örneği) )
                 throw new TypeError( "Sınıf işlev olarak çağrılamıyor" );
    
            i̇şte bu. üniforma = {};
            İşte bu. program = gl. createProgram();
    
            gl. attachShader(bu. program, vertexShader );
            gl. attachShader(bu. program, fragmentShader );
            gl. linkProgram(bu. program );
    
            eğer ( ! gl. getProgramParameter (bu. program, gl. LINK_STATUS ) ) gl atın. getProgramInfoLog( bu. program );
    
            var uniformCount = gl. getProgramParameter (bu. program, gl. ACTIVE_UNIFORMS );
            
            for ( var i = 0; i < uniformCount; i++ ) {
                
                var tekdüzenAdı = gl. getActiveUniform(bu. program, i). ad;
                
                İşte bu. üniformalar[ uniformName ] = gl. getUniformLocation (bu. program, tekdüzenAdı );
                
            }
        }
    
        GLProgram. prototipi. bağlama = işlev bağlama() {
            gl. useProgram(bu. program );
        };
    
        GLProgram döndürme;
        
    }();
    
    işlev compileShader( tür, kaynak ) {
    
        var gölgelendiricisi = gl. createShader( tür );
        
        gl. shaderSource( gölgelendirici, kaynak );
        gl. compileShader ( gölgelendirici );
    
        eğer ( ! gl. getShaderParameter (gölgelendirici, gl. COMPILE_STATUS ) ) gl atın. getShaderInfoLog ( gölgelendirici );
    
        gölgelendirici döndürme;
    
    }
    
    var baseVertexShader = compileShader( gl. VERTEX_SHADER, 'hassas highp float; precision mediump sampler2D; attribute vec2 aPosition; varying vec2 vUv; değişen vec2 vL; değişen vec2 vR; değişen vec2 vT; değişen vec2 vB; değişen vec2 vB; tekdüzen vec2 texelSize; void main () { vUv = aPosition * 0.5 + 0.5; vL = vUv - vec2(texelSize.x, 0.0); vR = vUv + vec2(texelSize.x, 0 0.0); vT = vUv + vec2(0.0, texelSize.y); vB = vUv - vec2(0.0, texelSize.y); gl_Position = vec4(aPosition,  0.0, 1.0); }' );
    var clearShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; varying vec2 vUv; uniform sampler2D uTexture; uniform float value; void main () { gl_FragColor = value * texture2D(uTexture, vUv); }' );
    var displayShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; varying vec2 vUv; uniform sampler2D uTexture; void main () { gl_FragColor = texture2D(uTexture, vUv); }' );
    var splatShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; hassas mediump sampler2D; değişen vec2 vUv; tek tip sampler2D uTarget; tek tip float aspectRatio; tekdüze vec3 renk; tekdüze vec2 noktası; tekdüze şamandıra yarıçapı; void main () { vec2 p = vUv - point.xy; p.x *= aspectRatio; vec3 splat = exp(-dot(p, p) / radius) * renk; vec3 tabanı = texture2D(uTarget, vUv).xyz; gl_FragColor = vec4(base + splat, 1.0); }' );
    var advectionManualFilteringShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; varying vec2 vUv; uniform sampler2D uVelocity; uniform sampler2D uSource; uniform vec2 texelSize; uniform float dt; uniform float dissipation; vec4 safrarp (sampler2D sam, in vec2 p) { vec4 st; st.xy = floor(p - 0.5) + 0.5; st.zw = st.xy + 1.0; vec4 uv = st * texelSize.xyxy; vec4 a = texture2D(sam, uv.xy); vec4 b = texture2D(sam,  uv.zy); vec4 c = texture2D(sam, uv.xw); vec4 d = texture2D(sam, uv.zw); vec2 f = p - st.xy; dönüş karışımı(mix(a, b, f.x), mix(c, d, f.x), f.y); } void main () { vec2 coord = gl_FragCoord.xy - dt * texture2D(uVelocity, vUv).xy; gl_FragColor = dağılma * safrarp(uSource, coord); gl_FragColor.a = 1.0; }' );
    var advectionShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; hassas mediump sampler2D; değişen vec2 vUv; tekdüzen sampler2D uVelocity; tekdüzen sampler2D uSource; tekdüzen vec2 texelSize; tekdüze float dt; tekdüzen şamandıra dağılımı; void main () { vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize; gl_FragColor = dağılma * texture2D(uSource, coord); }' );
    var divergenceShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uVelocity; vec2 sampleVelocity (in vec2 uv) { vec2 çarpan = vec2(1.0, 1.0); eğer (uv.x < 0.0) { uv.x = 0.0; çarpan.x = -1.0; } eğer (uv.x > 1.0) { uv.x = 1.0; çarpan.x = -1.0; } if (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; } if (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1. 0; } dönüş çarpanı * texture2D(uVelocity, uv).xy; } void main () { float L = sampleVelocity(vL).x; float R = sampleVelocity(vR).x; float T = sampleVelocity(vT).y; float B = sampleVelocity(vB).y; float div = 0,5 * (R - L + T - B); gl_FragColor = vec4(div, 0,0, 0,0, 1,0); }' );
    var curlShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; değişen vec2 vUv; değişen vec2 vL; değişen vec2 vR; değişen vec2 vT; değişen vec2 vB; tek tip sampler2D uVelocity; void main () { float L = texture2D(uVelocity, vL).y; float R = texture2D(uVelocity, vR).y; float T = texture2D(uVelocity, vT).x; float B = texture2D(uVelocity, vB).x; float vorticity = R - L - T + B; gl_FragColor = vec4(vorticity,  0.0, 0.0, 1.0); }' );
    var vorticityShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; hassas mediump sampler2D; değişen vec2 vUv; değişen vec2 vL; değişen vec2 vR; değişen vec2 vT; değişen vec2 vT; değişen vec2 vB; tekdüzen sampler2D uVelocity; tekdüzen sampler2D uCurl; tek tip float curl; tekdüze float dt; void main () { float L = texture2D(uCurl, vL).y; float R = texture2D(uCurl, vR).y; float T = texture2D(uCurl, vT).x; float B = texture2D(uCurl,  vB).x; float C = texture2D(uCurl, vUv).x; vec2 kuvveti = vec2(abs(T) - abs(B), abs(R) - abs(L)); kuvvet *= 1.0 / uzunluk (kuvvet + 0.00001) * kıvrılma * C; vec2 vel = texture2D(uVelocity, vUv).xy; gl_FragColor = vec4(vel + kuvvet * dt, 0.0, 1.0); }' );
    var pressureShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; değişen vec2 vR; değişen vec2 vT; değişen vec2 vB; uniform sampler2D uPressure; uniform sampler2D uDivergence; vec2 sınırı (vec2 uv içinde) { uv = min(max(uv, 0.0), 1.0); return uv; } void main () { float L = texture2D(uPressure, boundary(vL)).x; float R = texture2D(uPressure, boundary(vR)).x; float T = texture2D(uPressure,  sınır(vT)).x; float B = texture2D(uPressure, boundary(vB)).x; float C = texture2D(uPressure, vUv).x; float divergence = texture2D(uDivergence, vUv).x; şamandıra basıncı = (L + R + B + T - ayrışma) * 0,25; gl_FragColor = vec4(basınç, 0.0, 0.0, 1.0); }' );
    var gradientSubtractShader = compileShader( gl. FRAGMENT_SHADER, 'hassas highp float; hassas mediump sampler2D; değişen vec2 vUv; değişen vec2 vL; değişen vec2 vR; değişen vec2 vT; değişen vec2 vB; tek tip sampler2D uPressure; tek tip sampler2D uVelocity; vec2 sınırı (vec2 uv içinde) { uv = min(max(uv, 0.0), 1.0); return uv; } void main () { float L = texture2D(uPressure, boundary(vL)).x; float R = texture2D(uPressure, boundary(vR)).x; float T = texture2D(uPressure,  sınır(vT)).x; float B = texture2D(uPressure, boundary(vB)).x; vec2 hızı = texture2D(uVelocity, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(hız, 0.0, 1.0); }' );
    
    var textureWidth = boşluk 0;
    var textureHeight = void 0;
    var yoğunluğu = boşluk 0;
    var hızı = boşluk 0;
    var ayrışma = boşluk 0;
    var curl = boşluk 0;
    var basıncı = boşluk 0;
    
    initFramebuffers();
    
    var clearProgram = yeni GLProgram ( baseVertexShader, clearShader );
    var displayProgram = yeni GLProgram ( baseVertexShader, displayShader );
    var splatProgram = yeni GLProgram ( baseVertexShader, splatShader );
    var advectionProgram = yeni GLProgram ( baseVertexShader, support_linear_float ? advectionShader : advectionManualFilteringShader );
    var divergenceProgram = yeni GLProgram ( baseVertexShader, divergenceShader );
    var curlProgram = yeni GLProgram ( baseVertexShader, curlShader );
    var vorticityProgram = yeni GLProgram ( baseVertexShader, vorticityShader );
    var pressureProgram = yeni GLProgram ( baseVertexShader, pressureShader );
    var gradienSubtractProgram = yeni GLProgram ( baseVertexShader, gradientSubtractShader );
    
    initFramebuffers işlevi() {
    
        textureWidth = gl. çizimBufferWidth >> yapılandırma. TEXTURE_DOWNSAMPLE;
        textureHeight = gl. drawingBufferHeight >> yapılandırma. TEXTURE_DOWNSAMPLE;
    
        var iFormat = ext. internalFormat;
        var iFormatRG = ext. internalFormatRG;
        var formatRG = ext. formatRG;
        var texType = ext. texType;
    
        density = createDoubleFBO( 0, textureWidth, textureHeight, iFormat, gl. RGBA, texType, support_linear_float ? gl. DOĞRUSAL : gl. YAKIN );
        velocity = createDoubleFBO ( 2, textureWidth, textureHeight, iFormatRG, formatRG, texType, support_linear_float ? gl. DOĞRUSAL : gl. YAKIN );
        divergence = createFBO( 4, textureWidth, textureHeight, iFormatRG, formatRG, texType, gl. YAKIN );
        curl = createFBO( 5, textureWidth, textureHeight, iFormatRG, formatRG, texType, gl. YAKIN );
        basınç = createDoubleFBO( 6, textureWidth, textureHeight, iFormatRG, formatRG, texType, gl. YAKIN );
    
    }
    
    fonksiyon createFBO( texId, w, h, internalFormat, format, tür, param ) {
    
        gl. activeTexture( gl. TEXTURE0 + texId );
    
        var dokusu = gl. createTexture();
    
        gl. bindTexture( gl. TEXTURE_2D, doku );
        gl. texParameteri( gl. TEXTURE_2D, gl. TEXTURE_MIN_FILTER, param );
        gl. texParameteri( gl. TEXTURE_2D, gl. TEXTURE_MAG_FILTER, param );
        gl. texParameteri( gl. TEXTURE_2D, gl. TEXTURE_WRAP_S, gl. CLAMP_TO_EDGE );
        gl. texParameteri( gl. TEXTURE_2D, gl. TEXTURE_WRAP_T, gl. CLAMP_TO_EDGE );
        gl. texImage2D( gl. TEXTURE_2D, 0, internalFormat, w, h, 0, format, tür, null );
    
        var fbo = gl. createFramebuffer();
    
        gl. bindFramebuffer( gl. FRAMEBUFFER, fbo );
        gl. framebufferTexture2D( gl. FRAMEBUFFER, gl. COLOR_ATTACHMENT0, gl. TEXTURE_2D, doku, 0 );
        gl. görünüm penceresi( 0, 0, w, h );
        gl. clear( gl. COLOR_BUFFER_BIT );
    
        return [ doku, fbo, texId ];
    
    }
    
    function createDoubleFBO( texId, w, h, internalFormat, format, tür, param ) {
    
        var fbo1 = createFBO( texId, w, h, internalFormat, format, tür, param );
        var fbo2 = createFBO( texId + 1, w, h, internalFormat, format, tür, param );
    
        dönmek {
            önce almak() {
                 fbo1 döndür;
            },
            ikinci olmak() {
                fbo2 döndürme;
            },
            takas: fonksiyon takası() {
                var temp = fbo1;
    
                fbo1 = fbo2;
                fbo2 = geçici;
            }
        };
    
    }
    
    var blit = işlevi () {
    
        gl. bindBuffer( gl. ARRAY_BUFFER, gl. createBuffer() );
        gl. bufferData( gl. ARRAY_BUFFER, yeni Float32Array( [ -1, -1, -1, 1, 1, 1,  -1 ] ), gl. STATIC_DRAW );
        gl. bindBuffer( gl. ELEMENT_ARRAY_BUFFER, gl. createBuffer() );
        gl. bufferData( gl. ELEMENT_ARRAY_BUFFER, yeni Uint16Array( [ 0, 1, 2, 0, 2, 3 ] ), gl. STATIC_DRAW );
        gl. köşeli metinattribPointer( 0, 2, gl. FLOAT, yanlış, 0, 0 );
        gl. enableVertexAttribArray( 0 );
    
        dönüş işlevi ( hedef ) {
            gl. bindFramebuffer( gl. FRAMEBUFFER, hedef );
            gl. drawElements( gl. ÜÇGENLER, 6, gl. UNSIGNED_SHORT, 0 );
        };
    
    }();
    
    var lastTime = Tarih. şimdi();
    
    güncelleştirmek();
    
    işlev güncelleştirmesi() {
    
        yeniden boyutlandırmaCanvas();
    
        var dt = Matematik. min( (Tarih. now() - lastTime) / 1000, 0.016 );
        lastTime = Tarih. şimdi();
    
        gl. görünüm penceresi( 0, 0, textureWidth, textureHeight );
    
        if ( splatStack. uzunluk > 0 ) {
            için ( var m = 0; m < splatStack. pop(); ++ ) {
    
                var renk = [ Matematik. random() * 10, Matematik. random() * 10, Matematik. random() * 10 ];
                var x = tuval. genişlik * Matematik. rastgele();
                var y = tuval. yükseklik * Matematik. rastgele();
                var dx = 1000 * (Matematik. rastgele() - 0,5);
                var dy = 1000 * (Matematik. rastgele() - 0,5);
    
                splat( x, y, dx, dy, renk );
            }
        }
    
        advectionProgram. bağlamak();
        gl. uniform2f( advectionProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i (advectionProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        gl. uniform1i (advectionProgram. Üniformalar. uKaynak, hız. ilk[ 2 ] );
        gl. uniform1f( advectionProgram. Üniformalar. dt, dt );
        gl. uniform1f( advectionProgram. Üniformalar. dağılma, yapılandırma. VELOCITY_DISSIPATION );
        blit ( hız. ikinci[ 1 ] );
        hız. değiş tokuş etmek();
    
        gl. uniform1i (advectionProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        gl. uniform1i (advectionProgram. Üniformalar. uKaynak, yoğunluk. ilk[ 2 ] );
        gl. uniform1f( advectionProgram. Üniformalar. dağılma, yapılandırma. DENSITY_DISSIPATION );
        blit( yoğunluk. ikinci[ 1 ] );
        yoğunluğuna neden oldu. değiş tokuş etmek();
    
        için ( var i = 0, len = işaretçiler. uzunluk; i < len; i++ ) {
            var işaretçisi = işaretçiler[ i ];
    
            if ( işaretçi. taşındı ) {
                sıçrama (işaretçi. x, işaretçi. y, işaretçi. dx, işaretçi. dy, işaretçi. renk );
                işaretçisi. moved = yanlış;
            }
        }
    
        curlProgram. bağlamak();
        gl. uniform2f ( curlProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i (curlProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        blit( kıvrılma[ 1 ] );
    
        vorticityProgram. bağlamak();
        gl. uniform2f( vorticityProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i( vorticityProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        gl. uniform1i( vorticityProgram. Üniformalar. uCurl, kıvrılma[ 2 ] );
        gl. uniform1f( vorticityProgram. Üniformalar. kıvrılma, yapılandırma. CURL );
        gl. uniform1f( vorticityProgram. Üniformalar. dt, dt );
        blit ( hız. ikinci[ 1 ] );
        hız. değiş tokuş etmek();
    
        divergenceProgram. bağlamak();
        gl. uniform2f( divergenceProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i ( divergenceProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        blit( ayrışma[ 1 ] );
    
        clearProgram. bağlamak();
    
        var pressureTexId = basınç. ilk[ 2 ];
    
        gl. activeTexture( gl. TEXTURE0 + pressureTexId );
        gl. bindTexture( gl. TEXTURE_2D, baskı. ilk[ 0 ] );
        gl. uniform1i (clearProgram. Üniformalar. uTexture, pressureTexId );
        gl. uniform1f ( clearProgram. Üniformalar. değer, yapılandırma. PRESSURE_DISSIPATION );
        blit (basınç. ikinci[ 1 ] );
        basınç. değiş tokuş etmek();
    
        basınçProgram. bağlamak();
        gl. uniform2f (basınçProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i (basınçProgram. Üniformalar. uDivergence, ayrışma[ 2 ] );
        pressureTexId = basınç. ilk[ 2 ];
        gl. activeTexture( gl. TEXTURE0 + pressureTexId );
    
        for ( var _i = 0; _i < yapılandırma. PRESSURE_ITERATIONS; _i++ ) {
            gl. bindTexture( gl. TEXTURE_2D, baskı. ilk[ 0 ] );
            gl. uniform1i (basınçProgram. Üniformalar. uPressure, pressureTexId );
            blit (basınç. ikinci[ 1 ] );
            basınç. değiş tokuş etmek();
        }
    
        gradienSubtractProgram. bağlamak();
        gl. uniform2f( gradienSubtractProgram. Üniformalar. texelSize, 1.0 / textureWidth, 1.0 / textureHeight );
        gl. uniform1i( gradienSubtractProgram. Üniformalar. üPresure, basınç. ilk[ 2 ] );
        gl. uniform1i( gradienSubtractProgram. Üniformalar. uVelocity, hız. ilk[ 2 ] );
        blit ( hız. ikinci[ 1 ] );
        hız. değiş tokuş etmek();
    
        gl. görünüm penceresi( 0, 0, gl. çizimBufferWidth, gl. çizimBufferHeight );
        displayProgram. bağlamak();
        gl. uniform1i( displayProgram. Üniformalar. uTexture, yoğunluk. ilk[ 2 ] );
        blit( null );
    
        requestAnimationFrame( güncelleştirme );
    
    }
    
    fonksiyon plakası( x, y, dx, dy, renk ) {
    
        splatProgram. bağlamak();
        gl. uniform1i(splatProgram. Üniformalar. uTarget, hız. ilk[ 2 ] );
        gl. uniform1f( splatProgram. Üniformalar. aspectRatio, tuval. genişlik / tuval. yükseklik );
        gl. uniform2f( splatProgram. Üniformalar. nokta, x / tuval. genişlik, 1.0 - y / tuval. yükseklik );
        gl. uniform3f( splatProgram. Üniformalar. renk, dx, -dy, 1.0 );
        gl. uniform1f( splatProgram. Üniformalar. radius, yapılandırma. SPLAT_RADIUS );
        blit ( hız. ikinci[ 1 ] );
        hız. değiş tokuş etmek();
    
        gl. uniform1i(splatProgram. Üniformalar. uTarget, yoğunluk. ilk[ 2 ] );
        gl. uniform3f( splatProgram. Üniformalar. renk, renk[ 0 ] * 0.3, renk[ 1 ] * 0.3, renk[ 2 ] * 0.3 );
        blit( yoğunluk. ikinci[ 1 ] );
        yoğunluğuna neden oldu. değiş tokuş etmek();
    
    }
    
    işlevi yeniden boyutlandırCanvas() {
    
        ( tuval. genişlik !== tuval. clientWidth || tuval. yükseklik !== tuval. clientHeight )  &  width = tuval. clientWidth, tuval. yükseklik = tuval. clientHeight, initFramebuffers() );
    
    }
    
    var sayısı = 0;
    var colorArr = [ Matematik. random() + 0.2, Matematik. random() + 0.2, Matematik. random() + 0,2 ];
    
    tuval. addEventListener( 'mousemove', işlev ( e ) {
    
        saymak++;
    
        ( say > 25 )  & (colorArr = [ Matematik. random() + 0.2, Matematik. random() + 0.2, Matematik. random() + 0,2 ], sayı = 0);
    
        işaretçiler[ 0 ]. aşağı = doğru;
        işaretçiler[ 0 ]. renk = colorArr;
        işaretçiler[ 0 ]. moved = işaretçiler[ 0 ]. aşağı;
        işaretçiler[ 0 ]. dx = (e. offsetX - işaretçiler[ 0 ]. x) * 10.0;
        işaretçiler[ 0 ]. dy = (e. offsetY - işaretçiler[ 0 ]. y) * 10.0;
        işaretçiler[ 0 ]. x = e. offsetX;
        işaretçiler[ 0 ]. y = e. ofsetY;
    
    } );
    
    tuval. addEventListener( 'touchmove', işlev ( e ) {
    
        e. preventDefault();
    
        var dokunuşları = e. targetTouches;
    
        saymak++;
    
        ( say > 25 )  & (colorArr = [ Matematik. random() + 0.2, Matematik. random() + 0.2, Matematik. random() + 0,2 ], sayı = 0);
    
        için ( var i = 0, len = dokunuşlar. uzunluk; i < len; i++ ) {
    
            if ( i >= işaretçiler. length ) işaretçileri. push(yeni pointerPrototype() );
    
            işaretçiler[ i ]. id = dokunuşlar[ i ]. tanımlayıcı;
            işaretçiler[ i ]. aşağı = doğru;
            işaretçiler[ i ]. x = dokunuşlar[ i ]. pageX;
            işaretçiler[ i ]. y = dokunuşlar[ i ]. sayfaY;
            işaretçiler[ i ]. renk = colorArr;
    
            var işaretçisi = işaretçiler[ i ];
    
            işaretçisi. moved = işaretçi. aşağı;
            işaretçisi. dx = (dokunuşlar[ i ]. pageX - işaretçi. x) * 10.0;
            işaretçisi. dy = (dokunuşlar[ i ]. pageY - işaretçi. y) * 10.0;
            işaretçisi. x = dokunuşlar[ i ]. pageX;
            işaretçisi. y = dokunuşlar[ i ]. sayfaY;
    
        }
    
    }, yanlış );
    </betik>
    <betik>
                işlev renderTime() {
                var currentTime = yeni Tarih();
                var harcırah = "AM";
                var h = currentTime. getHours();
                var m = currentTime. getMinutes();
                var s = currentTime. getSeconds();
                setTimeout('renderTime()',1000);
                eğer (h == 0) {
                    h = 12;
                } else if (h > 12) { 
                    h = h - 12;
                    diem="PM";
                }
                eğer (h < 10) {
                    h = "0" + h;
                }
                eğer (m < 10) {
                    m = "0" + m;
                }
                if (s < 10) {
                    s = "0" + s;
                }
                var myClock = belge. getElementById('clockDisplay');
                myClock. textContent = h + ":" + m + ":" + s + " " + diem;
                myClock. innerText = h + ":" + m + ":" + s + " +  diem;
                }
                renderTime();
            </betik>
